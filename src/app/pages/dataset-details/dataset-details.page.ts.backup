import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { DatasetOperationsService } from '../../services/dataset-operations.service';
import { DatasetService } from '../../services/dataset.service';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { RouterModule } from '@angular/router';
import { SafeHtmlPipe } from '../../pipes/safe-html.pipe';
import { finalize } from 'rxjs/operators';

interface DatasetSchemaField {
  name: string;
  type: string;
  nullable: boolean;
  sampleValues: any[];
  description?: string;
}

interface PreviewData {
  headers: string[];
  data: Array<Record<string, any>>;
  schema: DatasetSchemaField[];
  totalRows: number;
}


import { 
  IonHeader, IonToolbar, IonButtons, IonButton, IonIcon, IonTitle, 
  IonContent, IonList, IonItem, IonLabel, IonSpinner, IonCard, IonCardHeader, 
  IonCardTitle, IonCardContent, IonBadge, IonText, IonNote, IonGrid, 
  IonRow, IonCol, IonAccordionGroup, IonAccordion, IonSelect, IonSelectOption,
  IonToggle, IonRange, IonInput, IonSegment, IonSegmentButton, IonBackButton
} from '@ionic/angular/standalone';

// PreviewTab type for tab switching
export type PreviewTab = 'preview' | 'schema';


@Component({
  selector: 'app-dataset-details',
  templateUrl: './dataset-details.page.html',
  styleUrls: ['./dataset-details.page.scss'],
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    RouterModule,
    SafeHtmlPipe,
    IonHeader, IonToolbar, IonButtons, IonButton, IonIcon, IonTitle,
    IonContent, IonList, IonItem, IonLabel, IonSpinner, IonCard, IonCardHeader,
    IonCardTitle, IonCardContent, IonBadge, IonText, IonNote, IonGrid,
    IonRow, IonCol, IonAccordionGroup, IonAccordion, IonSelect, IonSelectOption,
    IonToggle, IonRange, IonInput, IonSegment, IonSegmentButton, IonBackButton
  ]
})
export class DatasetDetailsPage implements OnInit {
  datasetId: string | null = null;
  isLoading = true;
  showDebugInfo = false;
  activeTab: PreviewTab = 'preview';
  previewRowsToShow = 5;
  previewData: PreviewData = {
    headers: [],
    data: [],
    schema: [],
    totalRows: 0
  };

  constructor(
    private route: ActivatedRoute,
    private datasetOps: DatasetOperationsService,
    private datasetService: DatasetService
  ) {}

  ngOnInit() {
    this.datasetId = this.route.snapshot.paramMap.get('id');
    if (this.datasetId) {
      this.loadDatasetInfo();
    } else {
      console.warn('No dataset ID found in route');
      this.isLoading = false;
    }
  }

  // --- Template Getters ---
  get hasPreviewData(): boolean {
    return this.previewData && Array.isArray(this.previewData.data) && this.previewData.data.length > 0;
  }

  get previewRowCount(): number {
    return this.previewData ? Math.min(this.previewRowsToShow, this.previewData.totalRows) : 0;
  }

  // --- Main Data Load ---
  loadDatasetInfo(): void {
    if (!this.datasetId) {
      console.warn('No dataset ID provided');
      this.isLoading = false;
      return;
    }
    this.isLoading = true;
    this.previewData = {
      headers: [],
      data: [],
      schema: [],
      totalRows: 0
    };
    this.datasetService.getDatasetContent(this.datasetId)
      .pipe(finalize(() => this.isLoading = false))
      .subscribe({
        next: (response: any) => {
          try {
            console.log('Raw dataset content response:', response);
            if (!response || !response.content) {
              throw new Error('No content received in the response');
            }
            // Parse CSV content
            const lines = response.content.split('\n').filter((line: string) => line.trim() !== '');
            if (lines.length === 0) {
              throw new Error('Empty dataset content');
            }
            // Parse headers (first line)
            const headers = this.parseCsvLine(lines[0]);
            // Parse data rows
            const data = [];
            for (let i = 1; i < Math.min(lines.length, this.previewRowsToShow + 1); i++) {
              if (lines[i].trim() === '') continue;
              const rowData = this.parseCsvLine(lines[i]);
              const row: Record<string, any> = { rowNumber: i };
              headers.forEach((header: string, index: number) => {
                row[header] = index < rowData.length ? rowData[index] : '';
              });
              data.push(row);
            }
            this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
}; headers, data, schema: [], totalRows: lines.length - 1 };
            this.loadSchema();
          } catch (error) {
            this.handlePreviewError(error);
          }
        },
        error: (error: any) => this.handlePreviewError(error)
      });
  }

  // --- Schema Load & Inference ---
  loadSchema(): void {
    if (!this.datasetId) {
  console.warn('No dataset ID provided');
  this.isLoading = false;
  return;
}
      this.inferSchemaFromPreviewData();
      return;
    }
    this.datasetOps.getDatasetSchema(this.datasetId).subscribe({
      next: (schemaResponse: any) => {
        try {
          if (!schemaResponse || !Array.isArray(schemaResponse)) {
            throw new Error('Invalid schema response format');
          }
          this.previewData.schema = schemaResponse.map((field: any) => ({
            name: field.name || 'unknown',
            type: field.type || 'string',
            nullable: field.nullable !== false,
            sampleValues: field.sampleValues || []
          }));
          if (this.previewData.data.length > 0) {
            this.updateSampleValuesFromPreviewData();
          }
        } catch (error) {
          this.inferSchemaFromPreviewData();
        }
      },
      error: () => this.inferSchemaFromPreviewData()
    });
  }

  private inferSchemaFromPreviewData(): void {
    if (!this.previewData.data.length) {
      this.previewData.schema = [];
      return;
    }
    const sampleRow = this.previewData.data[0];
    const headers = Object.keys(sampleRow).filter(key => key !== 'rowNumber');
    this.previewData.schema = headers.map(header => {
      const sampleValues = this.previewData.data
        .slice(0, 10)
        .map(row => row[header])
        .filter(val => val !== undefined && val !== null && val !== '');
      let type = 'string';
      if (sampleValues.length > 0) {
        const firstValue = sampleValues[0];
        if (!isNaN(Number(firstValue))) {
          type = 'number';
        } else if (typeof firstValue === 'string' && (firstValue.toLowerCase() === 'true' || firstValue.toLowerCase() === 'false')) {
          type = 'boolean';
        } else if (!isNaN(Date.parse(firstValue))) {
          type = 'date';
        }
      }
      return {
        name: header,
        type,
        nullable: sampleValues.length < 10,
        sampleValues: Array.from(new Set(sampleValues)).slice(0, 5)
      };
    });
  }

  private updateSampleValuesFromPreviewData(): void {
    if (!this.previewData.schema.length || !this.previewData.data.length) {
      return;
    }
    this.previewData.schema = this.previewData.schema.map(field => {
      const sampleValues = this.getDistinctValues(field.name, 5);
      return {
        ...field,
        sampleValues: sampleValues.length > 0 ? sampleValues : field.sampleValues
      };
    });
  }

  private getDistinctValues(column: string, maxSamples: number = 5): any[] {
    const uniqueValues = new Set<any>();
    for (const row of this.previewData.data) {
      if (row[column] !== undefined && row[column] !== null && row[column] !== '') {
        uniqueValues.add(row[column]);
        if (uniqueValues.size >= maxSamples) {
          break;
        }
      }
    }
    return Array.from(uniqueValues);
  }

  // --- Error Handling ---
  handlePreviewError(error: any): void {
    this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
};
      headers: [],
      data: [],
      schema: [],
      totalRows: 0
    };
    this.isLoading = false;
    console.error('Error loading dataset preview:', error);
  }

  // --- Utility Methods for Template ---
  getCellValue(row: any, header: string): any {
    return row[header] !== undefined ? row[header] : '';
  }

  formatCellValue(value: any): string {
    if (value === undefined || value === null || value === '') {
      return '—';
    }
    return String(value);
  }

  parseCsvLine(line: string): string[] {
    const result: string[] = [];
    let inQuotes = false;
    let currentField = '';
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        result.push(currentField.trim());
        currentField = '';
      } else {
        currentField += char;
      }
    }
    result.push(currentField.trim());
    return result;
  }

  // --- UI Methods ---
  onSegmentChange(event: any): void {
    const tab = event?.detail?.value;
    if (tab === 'preview' || tab === 'schema') {
      this.activeTab = tab;
    } else {
      this.activeTab = 'preview';
    }
  }

  toggleDebugInfo(): void {
    this.showDebugInfo = !this.showDebugInfo;
  }
}

  datasetId: string | null = null;
  isLoading = true;
  showDebugInfo = false;
  activeTab: PreviewTab = 'preview';
  previewRowsToShow = 5;
  previewData: PreviewData = {
    headers: [],
    data: [],
    schema: [],
    totalRows: 0
  };

  constructor(
    private route: ActivatedRoute,
    private datasetOps: DatasetOperationsService,
    private datasetService: DatasetService
  ) {}

  ngOnInit() {
    this.datasetId = this.route.snapshot.paramMap.get('id');
    if (this.datasetId) {
      this.loadDatasetInfo();
    } else {
      console.warn('No dataset ID found in route');
      this.isLoading = false;
    }
  }

  // --- Template Getters ---
  get hasPreviewData(): boolean {
    return this.previewData && Array.isArray(this.previewData.data) && this.previewData.data.length > 0;
  }

  get previewRowCount(): number {
    return this.previewData ? Math.min(this.previewRowsToShow, this.previewData.totalRows) : 0;
  }

  // --- Main Data Load ---
  loadDatasetInfo(): void {
    if (!this.datasetId) {
  console.warn('No dataset ID provided');
  this.isLoading = false;
  return;
}
      console.warn('No dataset ID provided');
      this.isLoading = false;
      return;
    }
    this.isLoading = true;
    this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
};
      headers: [],
      data: [],
      schema: [],
      totalRows: 0
    };
    this.datasetService.getDatasetContent(this.datasetId)
  .pipe(finalize(() => this.isLoading = false))
      .pipe(finalize(() => this.isLoading = false))
      .subscribe({
        next: (response: any) => {
  try {
    console.log('Raw dataset content response:', response);
    if (!response || !response.content) {
      throw new Error('No content received in the response');
    }
    // Parse CSV content
    const lines = response.content.split('\n').filter((line: string) => line.trim() !== '');
    if (lines.length === 0) {
      throw new Error('Empty dataset content');
    }
    // Parse headers (first line)
    const headers = this.parseCsvLine(lines[0]);
    // Parse data rows
    const data = [];
    for (let i = 1; i < Math.min(lines.length, this.previewRowsToShow + 1); i++) {
      if (lines[i].trim() === '') continue;
      const rowData = this.parseCsvLine(lines[i]);
      const row: Record<string, any> = { rowNumber: i };
      headers.forEach((header, index) => {
        row[header] = index < rowData.length ? rowData[index] : '';
      });
      data.push(row);
    }
    // Update preview data
    this.previewData = {
      headers,
      data,
      schema: [],
      totalRows: lines.length - 1 // Subtract 1 for header
    };
    // Load schema
    this.loadSchema();
  } catch (error) {
    console.error('Error parsing dataset content:', error);
    this.handlePreviewError(error);
  }
}
          try {
            const lines = response.content.split('\n').filter(line => line.trim() !== '');
            const headers = this.parseCsvLine(lines[0]);
            const data = [];
            for (let i = 1; i < Math.min(lines.length, this.previewRowsToShow + 1); i++) {
              if (lines[i].trim() === '') continue;
              const rowData = this.parseCsvLine(lines[i]);
              const row: Record<string, any> = { rowNumber: i };
              headers.forEach((header: string, index: number) => {
                row[header] = index < rowData.length ? rowData[index] : '';
              });
              data.push(row);
            }
            this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
}; headers, data, schema: [], totalRows: lines.length - 1 };
            this.loadSchema();
          } catch (error) {
            this.handlePreviewError(error);
          }
        },
        error: (error: any) => this.handlePreviewError(error)
      });
  }

  // --- Schema Load & Inference ---
  loadSchema(): void {
    if (!this.datasetId) {
  console.warn('No dataset ID provided');
  this.isLoading = false;
  return;
}
      this.inferSchemaFromPreviewData();
      return;
    }
    this.datasetOps.getDatasetSchema(this.datasetId).subscribe({
      next: (schemaResponse: any) => {
        try {
          if (!schemaResponse || !Array.isArray(schemaResponse)) {
            throw new Error('Invalid schema response format');
          }
          this.previewData.schema = schemaResponse.map((field: any) => ({
            name: field.name || 'unknown',
            type: field.type || 'string',
            nullable: field.nullable !== false,
            sampleValues: field.sampleValues || []
          }));
          if (this.previewData.data.length > 0) {
            this.updateSampleValuesFromPreviewData();
          }
        } catch (error) {
          this.inferSchemaFromPreviewData();
        }
      },
      error: () => this.inferSchemaFromPreviewData()
    });
  }

  private inferSchemaFromPreviewData(): void {
    if (!this.previewData.data.length) {
      this.previewData.schema = [];
      return;
    }
    const sampleRow = this.previewData.data[0];
    const headers = Object.keys(sampleRow).filter(key => key !== 'rowNumber');
    this.previewData.schema = headers.map(header => {
      const sampleValues = this.previewData.data
        .slice(0, 10)
        .map(row => row[header])
        .filter(val => val !== undefined && val !== null && val !== '');
      let type = 'string';
      if (sampleValues.length > 0) {
        const firstValue = sampleValues[0];
        if (!isNaN(Number(firstValue))) {
          type = 'number';
        } else if (typeof firstValue === 'string' && (firstValue.toLowerCase() === 'true' || firstValue.toLowerCase() === 'false')) {
          type = 'boolean';
        } else if (!isNaN(Date.parse(firstValue))) {
          type = 'date';
        }
      }
      return {
        name: header,
        type,
        nullable: sampleValues.length < 10,
        sampleValues: Array.from(new Set(sampleValues)).slice(0, 5)
      };
    });
  }

  private updateSampleValuesFromPreviewData(): void {
    if (!this.previewData.schema.length || !this.previewData.data.length) {
      return;
    }
    this.previewData.schema = this.previewData.schema.map(field => {
      const sampleValues = this.getDistinctValues(field.name, 5);
      return {
        ...field,
        sampleValues: sampleValues.length > 0 ? sampleValues : field.sampleValues
      };
    });
  }

  private getDistinctValues(column: string, maxSamples: number = 5): any[] {
    const uniqueValues = new Set<any>();
    for (const row of this.previewData.data) {
      if (row[column] !== undefined && row[column] !== null && row[column] !== '') {
        uniqueValues.add(row[column]);
        if (uniqueValues.size >= maxSamples) {
          break;
        }
      }
    }
    return Array.from(uniqueValues);
  }

  // --- Error Handling ---
  handlePreviewError(error: any): void {
    this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
};
      headers: [],
      data: [],
      schema: [],
      totalRows: 0
    };
    this.isLoading = false;
    console.error('Error loading dataset preview:', error);
  }

  // --- Utility Methods for Template ---
  getCellValue(row: any, header: string): any {
    return row[header] !== undefined ? row[header] : '';
  }

  formatCellValue(value: any): string {
    if (value === undefined || value === null || value === '') {
      return '—';
    }
    return String(value);
  }

  parseCsvLine(line: string): string[] {
    const result: string[] = [];
    let inQuotes = false;
    let currentField = '';
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        result.push(currentField.trim());
        currentField = '';
      } else {
        currentField += char;
      }
    }
    result.push(currentField.trim());
    return result;
  }

  // --- UI Methods ---
  onSegmentChange(event: any): void {
    const tab = event.detail?.value;
    if (tab === 'preview' || tab === 'schema') {
      this.activeTab = tab;
    } else {
      this.activeTab = 'preview';
    }
  }

  toggleDebugInfo(): void {
    this.showDebugInfo = !this.showDebugInfo;
  }
}

  datasetId: string | null = null;
  isLoading = true;
  showDebugInfo = false;
  activeTab: PreviewTab = 'preview';
  previewRowsToShow = 5;
  previewData: PreviewData = {
    headers: [],
    data: [],
    schema: [],
    totalRows: 0
  };

  constructor(
    private route: ActivatedRoute,
    private datasetOps: DatasetOperationsService,
    private datasetService: DatasetService
  ) {}

  ngOnInit() {
    this.datasetId = this.route.snapshot.paramMap.get('id');
    if (this.datasetId) {
      this.loadDatasetInfo();
    } else {
      console.warn('No dataset ID found in route');
      this.isLoading = false;
    }
  }

  // --- Template Getters ---
  get hasPreviewData(): boolean {
    return this.previewData && Array.isArray(this.previewData.data) && this.previewData.data.length > 0;
  }

  get previewRowCount(): number {
    return this.previewData ? Math.min(this.previewRowsToShow, this.previewData.totalRows) : 0;
  }

  // --- Main Data Load ---
  loadDatasetInfo(): void {
    if (!this.datasetId) {
  console.warn('No dataset ID provided');
  this.isLoading = false;
  return;
}
      console.warn('No dataset ID provided');
      this.isLoading = false;
      return;
    }
    this.isLoading = true;
    this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
};
      headers: [],
      data: [],
      schema: [],
      totalRows: 0
    };
    this.datasetService.getDatasetContent(this.datasetId)
  .pipe(finalize(() => this.isLoading = false))
      .pipe(finalize(() => this.isLoading = false))
      .subscribe({
        next: (response: any) => {
  try {
    console.log('Raw dataset content response:', response);
    if (!response || !response.content) {
      throw new Error('No content received in the response');
    }
    // Parse CSV content
    const lines = response.content.split('\n').filter((line: string) => line.trim() !== '');
    if (lines.length === 0) {
      throw new Error('Empty dataset content');
    }
    // Parse headers (first line)
    const headers = this.parseCsvLine(lines[0]);
    // Parse data rows
    const data = [];
    for (let i = 1; i < Math.min(lines.length, this.previewRowsToShow + 1); i++) {
      if (lines[i].trim() === '') continue;
      const rowData = this.parseCsvLine(lines[i]);
      const row: Record<string, any> = { rowNumber: i };
      headers.forEach((header, index) => {
        row[header] = index < rowData.length ? rowData[index] : '';
      });
      data.push(row);
    }
    // Update preview data
    this.previewData = {
      headers,
      data,
      schema: [],
      totalRows: lines.length - 1 // Subtract 1 for header
    };
    // Load schema
    this.loadSchema();
  } catch (error) {
    console.error('Error parsing dataset content:', error);
    this.handlePreviewError(error);
  }
}
          try {
            const lines = response.content.split('\n').filter(line => line.trim() !== '');
            const headers = this.parseCsvLine(lines[0]);
            const data = [];
            for (let i = 1; i < Math.min(lines.length, this.previewRowsToShow + 1); i++) {
              if (lines[i].trim() === '') continue;
              const rowData = this.parseCsvLine(lines[i]);
              const row: Record<string, any> = { rowNumber: i };
              headers.forEach((header: string, index: number) => {
                row[header] = index < rowData.length ? rowData[index] : '';
              });
              data.push(row);
            }
            this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
}; headers, data, schema: [], totalRows: lines.length - 1 };
            this.loadSchema();
          } catch (error) {
            this.handlePreviewError(error);
          }
        },
        error: (error: any) => this.handlePreviewError(error)
      });
  }

  // --- Schema Load & Inference ---
  loadSchema(): void {
    if (!this.datasetId) {
  console.warn('No dataset ID provided');
  this.isLoading = false;
  return;
}
      this.inferSchemaFromPreviewData();
      return;
    }
    this.datasetOps.getDatasetSchema(this.datasetId).subscribe({
      next: (schemaResponse: any) => {
        try {
          if (!schemaResponse || !Array.isArray(schemaResponse)) {
            throw new Error('Invalid schema response format');
          }
          this.previewData.schema = schemaResponse.map((field: any) => ({
            name: field.name || 'unknown',
            type: field.type || 'string',
            nullable: field.nullable !== false,
            sampleValues: field.sampleValues || []
          }));
          if (this.previewData.data.length > 0) {
            this.updateSampleValuesFromPreviewData();
          }
        } catch (error) {
          this.inferSchemaFromPreviewData();
        }
      },
      error: () => this.inferSchemaFromPreviewData()
    });
  }

  private inferSchemaFromPreviewData(): void {
    if (!this.previewData.data.length) {
      this.previewData.schema = [];
      return;
    }
    const sampleRow = this.previewData.data[0];
    const headers = Object.keys(sampleRow).filter(key => key !== 'rowNumber');
    this.previewData.schema = headers.map(header => {
      const sampleValues = this.previewData.data
        .slice(0, 10)
        .map(row => row[header])
        .filter(val => val !== undefined && val !== null && val !== '');
      let type = 'string';
      if (sampleValues.length > 0) {
        const firstValue = sampleValues[0];
        if (!isNaN(Number(firstValue))) {
          type = 'number';
        } else if (typeof firstValue === 'string' && (firstValue.toLowerCase() === 'true' || firstValue.toLowerCase() === 'false')) {
          type = 'boolean';
        } else if (!isNaN(Date.parse(firstValue))) {
          type = 'date';
        }
      }
      return {
        name: header,
        type,
        nullable: sampleValues.length < 10,
        sampleValues: Array.from(new Set(sampleValues)).slice(0, 5)
      };
    });
  }

  private updateSampleValuesFromPreviewData(): void {
    if (!this.previewData.schema.length || !this.previewData.data.length) {
      return;
    }
    this.previewData.schema = this.previewData.schema.map(field => {
      const sampleValues = this.getDistinctValues(field.name, 5);
      return {
        ...field,
        sampleValues: sampleValues.length > 0 ? sampleValues : field.sampleValues
      };
    });
  }

  private getDistinctValues(column: string, maxSamples: number = 5): any[] {
    const uniqueValues = new Set<any>();
    for (const row of this.previewData.data) {
      if (row[column] !== undefined && row[column] !== null && row[column] !== '') {
        uniqueValues.add(row[column]);
        if (uniqueValues.size >= maxSamples) {
          break;
        }
      }
    }
    return Array.from(uniqueValues);
  }

  // --- Error Handling ---
  handlePreviewError(error: any): void {
    this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
};
      headers: [],
      data: [],
      schema: [],
      totalRows: 0
    };
    this.isLoading = false;
    console.error('Error loading dataset preview:', error);
  }

  // --- Utility Methods for Template ---
  getCellValue(row: any, header: string): any {
    return row[header] !== undefined ? row[header] : '';
  }

  formatCellValue(value: any): string {
    if (value === undefined || value === null || value === '') {
      return '—';
    }
    return String(value);
  }

  parseCsvLine(line: string): string[] {
    const result: string[] = [];
    let inQuotes = false;
    let currentField = '';
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        result.push(currentField.trim());
        currentField = '';
      } else {
        currentField += char;
      }
    }
    result.push(currentField.trim());
    return result;
  }

  // --- UI Methods ---
  onSegmentChange(event: any): void {
    const tab = event.detail?.value;
    if (tab === 'preview' || tab === 'schema') {
      this.activeTab = tab;
    } else {
      this.activeTab = 'preview';
    }
  }

  toggleDebugInfo(): void {
    this.showDebugInfo = !this.showDebugInfo;
  }

  datasetId: string | null = null;
  isLoading = true;
  showDebugInfo = false;
  activeTab: PreviewTab = 'preview';
  previewRowsToShow = 5;
  previewData: PreviewData = {
    headers: [],
    data: [],
    schema: [],
    totalRows: 0
  };

  constructor(
    private route: ActivatedRoute,
    private datasetOps: DatasetOperationsService,
    private datasetService: DatasetService
  ) {}

  ngOnInit() {
    this.datasetId = this.route.snapshot.paramMap.get('id');
    if (this.datasetId) {
      this.loadDatasetInfo();
    } else {
      console.warn('No dataset ID found in route');
      this.isLoading = false;
    }
  }

  loadDatasetInfo(): void {
    if (!this.datasetId) {
  console.warn('No dataset ID provided');
  this.isLoading = false;
  return;
}
      console.warn('No dataset ID provided');
      this.isLoading = false;
      return;
    }
    this.isLoading = true;
    this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
};
      headers: [],
      data: [],
      schema: [],
      totalRows: 0,
    };
    this.datasetService.getDatasetContent(this.datasetId)
  .pipe(finalize(() => this.isLoading = false))
      .pipe(finalize(() => this.isLoading = false))
      .subscribe({
        next: (response: any) => {
  try {
    console.log('Raw dataset content response:', response);
    if (!response || !response.content) {
      throw new Error('No content received in the response');
    }
    // Parse CSV content
    const lines = response.content.split('\n').filter((line: string) => line.trim() !== '');
    if (lines.length === 0) {
      throw new Error('Empty dataset content');
    }
    // Parse headers (first line)
    const headers = this.parseCsvLine(lines[0]);
    // Parse data rows
    const data = [];
    for (let i = 1; i < Math.min(lines.length, this.previewRowsToShow + 1); i++) {
      if (lines[i].trim() === '') continue;
      const rowData = this.parseCsvLine(lines[i]);
      const row: Record<string, any> = { rowNumber: i };
      headers.forEach((header, index) => {
        row[header] = index < rowData.length ? rowData[index] : '';
      });
      data.push(row);
    }
    // Update preview data
    this.previewData = {
      headers,
      data,
      schema: [],
      totalRows: lines.length - 1 // Subtract 1 for header
    };
    // Load schema
    this.loadSchema();
  } catch (error) {
    console.error('Error parsing dataset content:', error);
    this.handlePreviewError(error);
  }
}
          try {
            if (!response || !response.content) {
              throw new Error('No content received in the response');
            }
            const lines = response.content.split('\n').filter((line: string) => line.trim() !== '');
            if (lines.length === 0) {
              throw new Error('Empty dataset content');
            }
            const headers = this.parseCsvLine(lines[0]);
            const data = [];
            for (let i = 1; i < Math.min(lines.length, this.previewRowsToShow + 1); i++) {
              if (lines[i].trim() === '') continue;
              const rowData = this.parseCsvLine(lines[i]);
              const row: Record<string, any> = { rowNumber: i };
              headers.forEach((header, index) => {
                row[header] = index < rowData.length ? rowData[index] : '';
              });
              data.push(row);
            }
            this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
};
              headers,
              data,
              schema: [],
              totalRows: lines.length - 1,
            };
            this.loadSchema();
          } catch (error) {
            this.handlePreviewError(error);
          }
        },
        error: (error: any) => {
          this.handlePreviewError(error);
        },
      });
  }

  loadSchema(): void {
    if (!this.datasetId) {
  console.warn('No dataset ID provided');
  this.isLoading = false;
  return;
}
      this.inferSchemaFromPreviewData();
      return;
    }
    this.datasetOps.getDatasetSchema(this.datasetId).subscribe({
      next: (schemaResponse: any) => {
        try {
          if (!schemaResponse || !Array.isArray(schemaResponse)) {
            throw new Error('Invalid schema response format');
          }
          this.previewData.schema = schemaResponse.map((field: any) => ({
            name: field.name || 'unknown',
            type: field.type || 'string',
            nullable: field.nullable !== false,
            sampleValues: field.sampleValues || [],
          }));
          if (this.previewData.data.length > 0) {
            this.updateSampleValuesFromPreviewData();
          }
        } catch (error) {
          this.inferSchemaFromPreviewData();
        }
      },
      error: () => {
        this.inferSchemaFromPreviewData();

  private loadSchema(): void {
  if (!this.datasetId) {
  console.warn('No dataset ID provided');
  this.isLoading = false;
  return;
}
    console.warn('No dataset ID available for schema loading');
    this.inferSchemaFromPreviewData();
    return;
  }
  this.datasetOps.getDatasetSchema(this.datasetId).subscribe({
    next: (schemaResponse: any) => {
      try {
        if (!schemaResponse || !Array.isArray(schemaResponse)) {
          throw new Error('Invalid schema response format');
        }
        this.previewData.schema = schemaResponse.map((field: any) => ({
          name: field.name || 'unknown',
          type: field.type || 'string',
          nullable: field.nullable !== false,
          sampleValues: field.sampleValues || []
        }));
        // Update sample values from preview data if available
        if (this.previewData.data.length > 0) {
          this.updateSampleValuesFromPreviewData();
        }
      } catch (error) {
      console.warn('No dataset ID available for schema loading');
      this.inferSchemaFromPreviewData();
      return;
    }
    this.datasetOps.getDatasetSchema(this.datasetId).subscribe({
      next: (schemaResponse: any) => {
        try {
          if (!schemaResponse || !Array.isArray(schemaResponse)) {
            throw new Error('Invalid schema response format');
          }
          this.previewData.schema = schemaResponse.map((field: any) => ({
            name: field.name || 'unknown',
            type: field.type || 'string',
            nullable: field.nullable !== false,
            sampleValues: field.sampleValues || []
          }));
          // Update sample values from preview data if available
          if (this.previewData.data.length > 0) {
            this.updateSampleValuesFromPreviewData();
          }
        } catch (error) {
          console.warn('Error processing schema, falling back to inference', error);
          this.inferSchemaFromPreviewData();
        }
      },
      error: (error) => {
  console.error('Error loading dataset content:', error);
  this.handlePreviewError(error);
}
        console.warn('Error loading schema, falling back to inference', error);
        this.inferSchemaFromPreviewData();
      }
    });
  }

  inferSchemaFromPreviewData(): void {
    if (!this.previewData.data.length) {
      console.warn('No preview data available for schema inference');
      this.previewData.schema = [];
      return;
    }
    const sampleRow = this.previewData.data[0];
    const headers = Object.keys(sampleRow).filter(key => key !== 'rowNumber');
    this.previewData.schema = headers.map(header => {
      // Sample values for type inference
      const sampleValues = this.previewData.data
        .slice(0, 10)
        .map(row => row[header])
        .filter(val => val !== undefined && val !== null && val !== '');
      // Simple type inference
      let type = 'string';
      if (sampleValues.length > 0) {
        const firstValue = sampleValues[0];
        if (!isNaN(Number(firstValue))) {
          type = 'number';
        } else if (firstValue.toLowerCase() === 'true' || firstValue.toLowerCase() === 'false') {
          type = 'boolean';
        } else if (!isNaN(Date.parse(firstValue))) {
          type = 'date';
        }
      }
      
      return {
        name: header,
        type,
        nullable: sampleValues.length < 10,
        sampleValues: Array.from(new Set(sampleValues)).slice(0, 5)
      };
    });
  }

  // --- Required Getters for Template ---
  get hasPreviewData(): boolean {
    return this.previewData && Array.isArray(this.previewData.data) && this.previewData.data.length > 0;
  }

  get previewRowCount(): number {
    return this.previewData ? Math.min(this.previewRowsToShow, this.previewData.totalRows) : 0;
  }

  // --- Data Methods ---
  private updateSampleValuesFromPreviewData(): void {
    if (!this.previewData.schema.length || !this.previewData.data.length) {
      return;
    }
    this.previewData.schema = this.previewData.schema.map(field => {
      const sampleValues = this.getDistinctValues(field.name, 5);
      return {
        ...field,
        sampleValues: sampleValues.length > 0 ? sampleValues : field.sampleValues
      };
    });
  }

  private getDistinctValues(column: string, maxSamples: number = 5): any[] {
    const uniqueValues = new Set<any>();
    for (const row of this.previewData.data) {
      if (row[column] !== undefined && row[column] !== null && row[column] !== '') {
        uniqueValues.add(row[column]);
        if (uniqueValues.size >= maxSamples) {
          break;
        }
      }
    }
    return Array.from(uniqueValues);
  }

  private handlePreviewError(error: any): void {
    console.error('Error loading dataset preview:', error);
    this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
};
      headers: [],
      data: [],
      schema: [],
      totalRows: 0
    };
    this.isLoading = false;
  }

  private parseCsvLine(line: string): string[] {
  const result: string[] = [];
  let inQuotes = false;
  let currentField = '';
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      result.push(currentField.trim());
      currentField = '';
    } else {
      currentField += char;
    }
  }
  result.push(currentField.trim());
  return result;
}
  const result: string[] = [];
  let inQuotes = false;
  let currentField = '';
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      result.push(currentField.trim());
      currentField = '';
    } else {
      currentField += char;
    }
  }
  result.push(currentField.trim());
  return result;
}
    const result: string[] = [];
    let inQuotes = false;
    let currentField = '';
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        result.push(currentField.trim());
        currentField = '';
      } else {
        currentField += char;
      }
    }
    result.push(currentField.trim());
    return result;
  }

  getCellValue(row: any, header: string): any {
    return row[header] !== undefined ? row[header] : '';
  }

  formatCellValue(value: any): string {
  if (value === undefined || value === null || value === '') {
    return '—';
  }
  return String(value);
}
    if (value === undefined || value === null || value === '') {
      return '—';
    }
    return String(value);
  }

  onSegmentChange(event: any) {
  const tab = event.detail?.value;
  if (tab === 'preview' || tab === 'schema') {
    this.activeTab = tab;
  } else {
    this.activeTab = 'preview';
  }
}
    const tab = event.detail?.value;
    if (tab === 'preview' || tab === 'schema') {
      this.activeTab = tab;
    } else {
      this.activeTab = 'preview';
    }
  }

  toggleDebugInfo() {
  this.showDebugInfo = !this.showDebugInfo;
}
    this.showDebugInfo = !this.showDebugInfo;
  }


  formatCellValue(value: any): string {
  if (value === undefined || value === null || value === '') {
    return '—';
  }
  return String(value);
}
    if (value === undefined || value === null || value === '') {
      return '—';
    }
    return String(value);
  }

  onSegmentChange(event: any) {
  const tab = event.detail?.value;
  if (tab === 'preview' || tab === 'schema') {
    this.activeTab = tab;
  } else {
    this.activeTab = 'preview';
  }
}
    const tab = event.detail?.value;
    if (tab === 'preview' || tab === 'schema') {
      this.activeTab = tab;
    } else {
      this.activeTab = 'preview'; // Default to preview if invalid tab
    }
  }

  toggleDebugInfo() {
  this.showDebugInfo = !this.showDebugInfo;
}
    this.showDebugInfo = !this.showDebugInfo;
  }



  /**
   * Loads dataset preview data and schema
   */
  /**
   * Loads dataset content using the read endpoint
   */
  loadDatasetInfo(): void {
  if (!this.datasetId) {
  console.warn('No dataset ID provided');
  this.isLoading = false;
  return;
}
    console.warn('No dataset ID provided');
    this.isLoading = false;
    return;
  }
  console.log(`Loading dataset content for ID: ${this.datasetId}`);
  this.isLoading = true;
  // Reset preview data
  this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
};
    headers: [],
    data: [],
    schema: [],
    totalRows: 0
  };
  // Load dataset content
  this.datasetService.getDatasetContent(this.datasetId)
  .pipe(finalize(() => this.isLoading = false))
    .pipe(finalize(() => this.isLoading = false))
    .subscribe({
      next: (response: any) => {
  try {
    console.log('Raw dataset content response:', response);
    if (!response || !response.content) {
      throw new Error('No content received in the response');
    }
    // Parse CSV content
    const lines = response.content.split('\n').filter((line: string) => line.trim() !== '');
    if (lines.length === 0) {
      throw new Error('Empty dataset content');
    }
    // Parse headers (first line)
    const headers = this.parseCsvLine(lines[0]);
    // Parse data rows
    const data = [];
    for (let i = 1; i < Math.min(lines.length, this.previewRowsToShow + 1); i++) {
      if (lines[i].trim() === '') continue;
      const rowData = this.parseCsvLine(lines[i]);
      const row: Record<string, any> = { rowNumber: i };
      headers.forEach((header, index) => {
        row[header] = index < rowData.length ? rowData[index] : '';
      });
      data.push(row);
    }
    // Update preview data
    this.previewData = {
      headers,
      data,
      schema: [],
      totalRows: lines.length - 1 // Subtract 1 for header
    };
    // Load schema
    this.loadSchema();
  } catch (error) {
    console.error('Error parsing dataset content:', error);
    this.handlePreviewError(error);
  }
}
        try {
          console.log('Raw dataset content response:', response);
          if (!response || !response.content) {
            throw new Error('No content received in the response');
          }
          // Parse CSV content
          const lines = response.content.split('\n').filter((line: string) => line.trim() !== '');
          if (lines.length === 0) {
            throw new Error('Empty dataset content');
          }
          // Parse headers (first line)
          const headers = this.parseCsvLine(lines[0]);
          // Parse data rows
          const data = [];
          for (let i = 1; i < Math.min(lines.length, this.previewRowsToShow + 1); i++) {
            if (lines[i].trim() === '') continue;
            const rowData = this.parseCsvLine(lines[i]);
            const row: Record<string, any> = { rowNumber: i };
            headers.forEach((header, index) => {
              row[header] = index < rowData.length ? rowData[index] : '';
            });
            data.push(row);
      error: (error) => {
  console.error('Error loading dataset content:', error);
  this.handlePreviewError(error);
}
        console.error('Error loading dataset content:', error);
        this.handlePreviewError(error);
      }
    });
}
    if (!this.datasetId) {
  console.warn('No dataset ID provided');
  this.isLoading = false;
  return;
}
      console.warn('No dataset ID provided');
      this.isLoading = false;
      return;
    }
    
    console.log(`Loading dataset content for ID: ${this.datasetId}`);
    this.isLoading = true;
    
    // Reset preview data
    this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
};
      headers: [],
      data: [],
      schema: [],
      totalRows: 0
    };
    
    // Load dataset content using the read endpoint
    this.datasetService.getDatasetContent(this.datasetId)
  .pipe(finalize(() => this.isLoading = false)).subscribe({
      next: (response: any) => {
  try {
    console.log('Raw dataset content response:', response);
    if (!response || !response.content) {
      throw new Error('No content received in the response');
    }
    // Parse CSV content
    const lines = response.content.split('\n').filter((line: string) => line.trim() !== '');
    if (lines.length === 0) {
      throw new Error('Empty dataset content');
    }
    // Parse headers (first line)
    const headers = this.parseCsvLine(lines[0]);
    // Parse data rows
    const data = [];
    for (let i = 1; i < Math.min(lines.length, this.previewRowsToShow + 1); i++) {
      if (lines[i].trim() === '') continue;
      const rowData = this.parseCsvLine(lines[i]);
      const row: Record<string, any> = { rowNumber: i };
      headers.forEach((header, index) => {
        row[header] = index < rowData.length ? rowData[index] : '';
      });
      data.push(row);
    }
    // Update preview data
    this.previewData = {
      headers,
      data,
      schema: [],
      totalRows: lines.length - 1 // Subtract 1 for header
    };
    // Load schema
    this.loadSchema();
  } catch (error) {
    console.error('Error parsing dataset content:', error);
    this.handlePreviewError(error);
  }
}
        try {
          console.log('Raw dataset content response:', response);
          
          if (!response || !response.content) {
            throw new Error('No content received in the response');
          }
          
          // Parse CSV content
          const lines = response.content.split('\n').filter((line: string) => line.trim() !== '');
          if (lines.length === 0) {
            throw new Error('Empty dataset content');
          }
          
          // Parse headers (first line)
          const headers = this.parseCsvLine(lines[0]);
          
          // Parse data rows
          const data = [];
          for (let i = 1; i < Math.min(lines.length, this.previewRowsToShow + 1); i++) {
            if (lines[i].trim() === '') continue;
            const values = this.parseCsvLine(lines[i]);
            const row: Record<string, any> = { rowNumber: i };
            headers.forEach((header, index) => {
              row[header] = values[index] || '';
            });
            data.push(row);
          }
          
          console.log('Parsed CSV data:', { 
            headers, 
            rowCount: data.length, 
            totalRows: lines.length - 1,
            firstRow: data[0] || null 
          });
          
          // Update component state
          this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
};
            headers,
            data,
            schema: [],
            totalRows: lines.length - 1
          };
          
          // Load schema after preview data is processed
          this.loadSchema();
          
        } catch (error) {
          console.error('Error parsing dataset content:', error);
          this.handlePreviewError(error);
        }
      },
      error: (error: any) => {
        console.error('Error loading dataset content:', error);
        this.handlePreviewError(error);
      }
    });
  }
  
  /**
   * Parses a single CSV line, handling quoted fields
   */
  private parseCsvLine(line: string): string[] {
  const result: string[] = [];
  let inQuotes = false;
  let currentField = '';
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      result.push(currentField.trim());
      currentField = '';
    } else {
      currentField += char;
    }
  }
  result.push(currentField.trim());
  return result;
}
  const result: string[] = [];
  let inQuotes = false;
  let currentField = '';
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      result.push(currentField.trim());
      currentField = '';
    } else {
      currentField += char;
    }
  }
  result.push(currentField.trim());
  return result;
}
    const result: string[] = [];
    let inQuotes = false;
    let currentField = '';
    
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      
      if (char === '"') {
        // Toggle inQuotes when we hit a quote
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        // End of field
        result.push(currentField.trim());
        currentField = '';
      } else {
        currentField += char;
      }
    }
    
    // Add the last field
    result.push(currentField.trim());
    
    return result;
  }
  }
  }

  /**
   * Loads and processes the dataset schema
   */
  private loadSchema(): void {
  if (!this.datasetId) {
  console.warn('No dataset ID provided');
  this.isLoading = false;
  return;
}
    console.warn('No dataset ID available for schema loading');
    this.inferSchemaFromPreviewData();
    return;
  }
  this.datasetOps.getDatasetSchema(this.datasetId).subscribe({
    next: (schemaResponse: any) => {
      try {
        if (!schemaResponse || !Array.isArray(schemaResponse)) {
          throw new Error('Invalid schema response format');
        }
        this.previewData.schema = schemaResponse.map((field: any) => ({
          name: field.name || 'unknown',
          type: field.type || 'string',
          nullable: field.nullable !== false,
          sampleValues: field.sampleValues || []
        }));
        // Update sample values from preview data if available
        if (this.previewData.data.length > 0) {
          this.updateSampleValuesFromPreviewData();
        }
      } catch (error) {
        console.warn('Error processing schema, falling back to inference', error);
        this.inferSchemaFromPreviewData();
      }
    },
    error: (error) => {
  console.error('Error loading dataset content:', error);
  this.handlePreviewError(error);
}
      console.warn('Error loading schema, falling back to inference', error);
      this.inferSchemaFromPreviewData();
    }
  });
}
    if (!this.datasetId) {
  console.warn('No dataset ID provided');
  this.isLoading = false;
  return;
}
      console.warn('No dataset ID available for schema loading');
      this.inferSchemaFromPreviewData();
      return;
    }

    this.datasetOps.getDatasetSchema(this.datasetId).subscribe({
      next: (schemaResponse: any) => {
        try {
          if (!schemaResponse || !Array.isArray(schemaResponse)) {
            throw new Error('Invalid schema response format');
          }
          
          this.previewData.schema = schemaResponse.map((field: any) => ({
            name: field.name || 'unknown',
            type: field.type || 'string',
            nullable: field.nullable !== false,
            sampleValues: field.sampleValues || []
          }));

          // Update schema with sample values from preview data
          if (this.previewData && Array.isArray(this.previewData.data) && this.previewData.data.length > 0) {
            const sampleData = this.previewData.data.slice(0, 5);
            this.previewData.schema.forEach(field => {
              const sampleValues = sampleData.map(row => row[field.name]);
              field.sampleValues = sampleValues.filter(v => v !== null && v !== undefined && v !== '').slice(0, 5);
            });
          }

          console.log('Loaded and processed schema:', this.previewData.schema);
        } catch (error) {
          console.error('Error processing schema:', error);
          this.inferSchemaFromPreviewData();
        } finally {
          this.isLoading = false;
        }
      },
      error: (error: any) => {
        console.error('Error loading schema:', error);
        this.inferSchemaFromPreviewData();
        this.isLoading = false;
      }
    });
  }

  /**
   * Infers schema from the available preview data
   */
  private inferSchemaFromPreviewData(): void {
  if (!this.previewData.data.length) {
    console.warn('No preview data available for schema inference');
    this.previewData.schema = [];
    return;
  }
  const sampleRow = this.previewData.data[0];
  const headers = Object.keys(sampleRow).filter(key => key !== 'rowNumber');
  this.previewData.schema = headers.map(header => {
    // Sample values for type inference
    const sampleValues = this.previewData.data
      .slice(0, 10)
      .map(row => row[header])
      .filter(val => val !== undefined && val !== null && val !== '');
    // Simple type inference
    let type = 'string';
    if (sampleValues.length > 0) {
      const firstValue = sampleValues[0];
      if (!isNaN(Number(firstValue))) {
        type = 'number';
      } else if (typeof firstValue === 'string' && (firstValue.toLowerCase() === 'true' || firstValue.toLowerCase() === 'false')) {
        type = 'boolean';
      } else if (!isNaN(Date.parse(firstValue))) {
        type = 'date';
      }
    }
    return {
      name: header,
      type,
      nullable: sampleValues.length < 10,
      sampleValues: Array.from(new Set(sampleValues)).slice(0, 5)
    };
  });
}
    try {
      if (!this.previewData || !Array.isArray(this.previewData.data) || this.previewData.data.length === 0) {
        console.warn('No preview data available for schema inference');
        this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
};
          ...this.previewData,
          schema: []
        };
        this.isLoading = false;
        return;
      }
      
      const schema = this.inferSchemaFromData(this.previewData.data);
      this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
};
        ...this.previewData,
        schema
      };
    } catch (error) {
      console.error('Error inferring schema from preview data:', error);
      this.previewData = {
  headers: [],
  data: [],
  schema: [],
  totalRows: 0
};
        ...this.previewData,
        schema: []
      };
    } finally {
      this.isLoading = false;
    }
  }

  private inferSchemaFromData(data: Array<Record<string, any>>): DatasetSchemaField[] {
    if (!data || data.length === 0) return [];
    
    const firstDataRow = data.find(row => Object.keys(row).length > 0);
    if (!firstDataRow) return [];
    
    return Object.keys(firstDataRow)
      .filter(key => key !== 'rowNumber')
      .map(header => ({
        name: header,
        type: this.inferType([firstDataRow[header]]),
        nullable: data.some(row => row[header] === null || row[header] === undefined || row[header] === ''),
        sampleValues: this.getSampleValues(data, header, 5)
      }));
  }

  private getSampleValues(data: Array<Record<string, any>>, column: string, maxSamples: number = 5): any[] {
    const uniqueValues = new Set<any>();
    
    for (const row of data) {
      if (row[column] !== undefined && row[column] !== null && row[column] !== '') {
        const value = String(row[column]).trim();
        if (value) {
          uniqueValues.add(value);
          if (uniqueValues.size >= maxSamples) break;
        }
      }
    }
    
    return Array.from(uniqueValues);
  }

  getCellValue(row: any, header: string): any {
  return row[header] !== undefined ? row[header] : '';
}
    if (!row || !column) return '<span class="null-value">—</span>';
    
    const value = row[column];
    
    if (value === null || value === undefined || value === '') {
      return '<span class="null-value">—</span>';
    }
    
    return String(value).trim();
  }

  private onSegmentChange(event: any): void {
    const tab = event.detail.value as PreviewTab;
    this.activeTab = tab;
  }
}
